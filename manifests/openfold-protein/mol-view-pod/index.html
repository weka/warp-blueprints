<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>OpenFold PDB Viewer</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; }
    #app { width: 100%; height: 100%; }
  </style>
  <!-- Tailwind (for styling to match app theme) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Mol* from CDN (pin version to avoid breaking API changes) -->
  <link rel="stylesheet" href="https://unpkg.com/molstar@3.37.0/build/viewer/molstar.css" />
  <script src="https://unpkg.com/molstar@3.37.0/build/viewer/molstar.js"></script>
</head>
<body>
  <div class="w-full h-full bg-neutral-900 text-neutral-100 flex">
    <!-- Sidebar: directory browser -->
    <div class="hidden md:flex md:flex-col md:w-80 border-r border-neutral-800 bg-neutral-950">
      <div class="px-4 py-3 text-sm font-medium tracking-wide text-neutral-300 border-b border-neutral-800">
        Browse mounted files (/data → /files)
      </div>
      <iframe id="browser" src="/files/" class="flex-1 w-full bg-neutral-950"></iframe>
      <div class="px-4 py-2 text-xs text-neutral-400 border-t border-neutral-800">
        Tip: Click a file (.pdb, .cif/.mmcif, .bcif, .gz) to load it. Click folders to navigate.
      </div>
    </div>

    <!-- Main viewer area -->
    <div class="flex-1 flex flex-col min-w-0">
      <div class="px-4 py-3 text-sm border-b border-neutral-800 flex items-center justify-between">
        <div>
          <span class="text-neutral-300">Mol* Viewer</span>
          <span id="current-file" class="ml-2 text-neutral-500"></span>
        </div>
        <div class="space-x-2">
          <button id="reset-btn" class="px-2.5 py-1.5 rounded bg-neutral-800 text-neutral-200 hover:bg-neutral-700 text-xs">Reset</button>
        </div>
      </div>
      <div class="flex-1 min-h-0" id="app"></div>
    </div>
  </div>
  <script>
    const viewer = new molstar.Viewer('app', {
      layoutIsExpanded: true,
      layoutShowControls: true,
      layoutShowRemoteState: false,
      layoutShowSequence: true,
      layoutShowLog: false,
      layoutShowLeftPanel: true,
    });

    // Normalize path by stripping any query/hash
    function normalizePath(path) {
      const i = path.indexOf('?');
      const j = path.indexOf('#');
      let end = path.length;
      if (i !== -1) end = Math.min(end, i);
      if (j !== -1) end = Math.min(end, j);
      return path.slice(0, end);
    }

    // Helper to determine format from file extension
    function inferFormat(path) {
      const p = normalizePath(path).toLowerCase();
      if (p.endsWith('.bcif') || p.endsWith('.bcif.gz')) return 'bcif';
      if (p.endsWith('.cif') || p.endsWith('.cif.gz') || p.endsWith('.mmcif')) return 'mmcif';
      return 'pdb';
    }

    // Helper to determine if the requested resource should be fetched as binary
    function isBinaryForPath(path) {
      const p = normalizePath(path).toLowerCase();
      return p.endsWith('.bcif') || p.endsWith('.bcif.gz') || p.endsWith('.gz');
    }

    function isStructureFile(path) {
      const p = normalizePath(path).toLowerCase();
      return p.endsWith('.pdb') || p.endsWith('.ent') || p.endsWith('.cif') || p.endsWith('.mmcif') || p.endsWith('.bcif') || p.endsWith('.gz');
    }

    const currentFileEl = document.getElementById('current-file');
    const resetBtn = document.getElementById('reset-btn');

    async function loadFile(urlPath) {
      const displayName = urlPath.replace(/^\/files\//, '');
      const norm = normalizePath(urlPath);
      const format = inferFormat(norm);
      const isBinary = isBinaryForPath(norm);
      currentFileEl.textContent = `— loading ${displayName} ...`;
      console.debug('Mol* load attempt', {
        molstarVersion: (window.molstar && molstar.VERSION) || 'unknown',
        urlPath, norm, format, isBinary
      });

      // Try the tuple signature first, then fall back to the object signature used by some Mol* builds
      try {
        // Signature: (url, format, isBinary, options)
        await viewer.loadStructureFromUrl(norm, format, isBinary, { customId: norm, label: displayName });
      } catch (e1) {
        console.warn('First load method failed, retrying with object signature…', e1);
        try {
          // Fallback signature: ({ url, format, isBinary, label })
          await viewer.loadStructureFromUrl({ url: norm, format, isBinary, label: displayName });
        } catch (e2) {
          console.error('Failed to load structure with both methods:', e2);
          currentFileEl.textContent = '— failed to load';
          return;
        }
      }

      // If we got here, the structure was queued/loaded successfully
      try {
        // Apply a sensible default view if available, but don't fail the load if preset API differs
        if (molstar && molstar.PresetStructureHierarchy && typeof viewer.applyPreset === 'function') {
          await viewer.applyPreset(molstar.PresetStructureHierarchy);
        }
      } catch (presetErr) {
        console.debug('Preset application skipped/failed (non-fatal):', presetErr);
      }
      currentFileEl.textContent = `— ${displayName}`;
    }

    // Hook into the autoindex page inside the iframe to intercept file clicks
    const browser = document.getElementById('browser');
    function attachBrowserHandlers() {
      try {
        const doc = browser.contentDocument || browser.contentWindow.document;
        if (!doc) return;
        const anchors = Array.from(doc.querySelectorAll('a[href]'));
        anchors.forEach(a => {
          a.addEventListener('click', (e) => {
            const href = a.getAttribute('href');
            if (!href) return;
            // Ignore query/hash/absolute links produced by autoindex controls
            if (href.startsWith('?') || href.startsWith('#') || href.startsWith('http://') || href.startsWith('https://')) {
              return;
            }
            // Allow directory navigation (usually ends with '/'), intercept files
            if (href.endsWith('/')) {
              return; // let iframe navigate
            }
            if (isStructureFile(href)) {
              e.preventDefault();
              if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
              const basePath = new URL(browser.contentWindow.location.href).pathname; // e.g. /files/subdir/
              // Resolve possibly relative href against the current directory
              const resolved = new URL(href, window.location.origin + basePath).pathname;
              // Sanity: ensure it stays under /files/
              const urlPath = resolved.startsWith('/files/') ? resolved : ('/files/' + resolved.replace(/^\/+/, ''));
              loadFile(urlPath);
            }
          }, { capture: true });
        });
      } catch (err) {
        console.warn('Could not attach browser handlers:', err);
      }
    }
    browser.addEventListener('load', attachBrowserHandlers);

    // Reset clears the current file and the viewer state
    resetBtn.addEventListener('click', async () => {
      try {
        await viewer.clear();
        currentFileEl.textContent = '';
      } catch (e) {
        console.warn('Reset error:', e);
      }
    });
  </script>
</body>
</html>